ID: ADM-02
Title: Изменения весовых таблиц не применяются при редактировании
Type: bug
Priority: P1
Status: Open
Owner: backend, frontend
Created: 2025-01-27

Кратко
— При редактировании весовой таблицы в интерфейсе `/admin/weights` изменения не применяются к существующей таблице. Вместо этого всегда создаётся новая версия таблицы, которая не активируется автоматически. В результате пользователь видит, что изменения сохранены, но они не используются в расчётах.

Контекст
— В текущей реализации система весовых таблиц использует версионирование: каждая таблица имеет поле `version` и флаг `is_active`. При создании новой таблицы через `POST /api/admin/weights/upload` всегда создаётся новая версия (инкремент версии), но она не активируется автоматически. Для применения изменений администратор должен вручную активировать новую версию через `POST /api/admin/weights/{id}/activate`.

— На фронтенде при редактировании таблицы (кнопка "Редактировать" в модальном окне) вызывается тот же эндпоинт `upload`, который создаёт новую версию. Пользователь видит сообщение "Таблица сохранена", но изменения не применяются, так как новая версия не активирована, а старая остаётся активной.

Проблема
1. **Отсутствие эндпоинта для обновления:**
   - В `app/routers/weights.py` есть только `POST /upload` (создание новой версии) и `POST /{id}/activate` (активация)
   - Нет эндпоинта `PUT /{id}` или `PATCH /{id}` для обновления существующей таблицы

2. **Фронтенд всегда создаёт новую версию:**
   - В `frontend/src/views/AdminWeightsView.vue` метод `saveTable()` всегда вызывает `weightsApi.upload()`
   - Даже при редактировании (`editingTable.value` установлен) создаётся новая версия вместо обновления

3. **Механика активации усложняет UX:**
   - Пользователь должен помнить активировать новую версию после редактирования
   - Два шага вместо одного: "Сохранить" → "Активировать"
   - Риск забыть активировать и работать со старой версией

4. **Хранение старых версий может быть избыточным:**
   - Система хранит все версии таблиц в БД
   - Если версионирование не требуется для аудита/истории, это усложняет модель данных

Ожидаемое поведение
— При редактировании существующей весовой таблицы:
  - Изменения должны применяться к текущей активной таблице (или автоматически активировать новую версию)
  - Пользователь должен видеть, что изменения применены и используются в расчётах
  - Один шаг: "Сохранить" → изменения применены

— При создании новой таблицы:
  - Создаётся новая таблица и автоматически активируется (если для области ещё нет активной таблицы)
  - Если уже есть активная таблица — либо обновить её, либо показать предупреждение

Зона изменений

**Backend (FastAPI):**

1. **Новый эндпоинт для обновления:**
   - `PUT /api/admin/weights/{weight_table_id}` — обновление существующей таблицы
   - Валидация: проверка суммы весов = 1.0, уникальность метрик
   - Обновление поля `weights` и `metadata_json` в существующей записи
   - Если таблица активна — изменения применяются сразу

2. **Упрощение логики активации (опционально):**
   - Рассмотреть удаление механики активации (`is_active`) и версионирования (`version`)
   - Если версионирование не требуется — хранить одну таблицу на область
   - Если требуется история — автоматически активировать новую версию при создании/обновлении

3. **Сервис:**
   - `WeightTableService.update_weight_table()` — метод для обновления существующей таблицы
   - `WeightTableService.upload_weight_table()` — автоматически активировать новую версию (если версионирование сохраняется)

4. **Репозиторий:**
   - `WeightTableRepository.update()` — обновление полей `weights` и `metadata_json`
   - Если удаляется версионирование — упростить модель (убрать `version`, `is_active`)

**Frontend (Vue 3):**

1. **API клиент:**
   - Добавить метод `weightsApi.update(weightTableId, data)` в `frontend/src/api/weights.js`
   - Вызов `PUT /api/admin/weights/{id}`

2. **Компонент AdminWeightsView:**
   - В методе `saveTable()` проверять `editingTable.value`:
     - Если редактирование → вызывать `weightsApi.update()`
     - Если создание → вызывать `weightsApi.upload()`
   - После сохранения обновлять список таблиц и показывать актуальное состояние

3. **UX улучшения:**
   - Показывать индикатор активной таблицы в списке
   - После сохранения показывать сообщение "Изменения применены" (не просто "Таблица сохранена")
   - Если создаётся новая версия — предупреждение "Создана новая версия, требуется активация" (если активация сохраняется)

**База данных (Alembic):**

1. **Если удаляется версионирование:**
   - Миграция для удаления полей `version`, `is_active` из `weight_table`
   - Удаление уникального индекса `uq_weight_table_prof_activity_version_unique`
   - Удаление индекса `uq_weight_table_prof_activity_active`
   - Добавление уникального ограничения на `prof_activity_id` (одна таблица на область)

2. **Если версионирование сохраняется:**
   - Рассмотреть автоматическую активацию новой версии при создании (деактивация старой)
   - Или добавить флаг "автоактивация" в запрос

Тестирование

**Backend (pytest):**
- Обновление существующей активной таблицы → веса изменены, таблица остаётся активной
- Обновление неактивной таблицы → веса изменены, статус не изменился
- Создание новой таблицы для области без активной → автоматически активируется
- Создание новой таблицы для области с активной → либо обновление активной, либо создание новой версии (в зависимости от выбранного подхода)
- Валидация: сумма весов ≠ 1.0 → ошибка 400
- Валидация: дубликаты метрик → ошибка 400

**Frontend (vitest/e2e):**
- Редактирование таблицы → вызывается `PUT /api/admin/weights/{id}`
- Создание новой таблицы → вызывается `POST /api/admin/weights/upload`
- После сохранения список таблиц обновляется
- Сообщения об успехе корректны

Критерии приёмки
- При редактировании весовой таблицы изменения применяются к активной таблице и используются в расчётах
- Пользователь видит, что изменения применены (один шаг, без необходимости активации)
- Если версионирование удалено — модель данных упрощена (нет `version`, `is_active`)
- Если версионирование сохранено — новая версия автоматически активируется при создании/обновлении
- Старые неактивные версии либо удаляются, либо хранятся для истории (в зависимости от требований)
- API поддерживает обновление существующих таблиц через `PUT /api/admin/weights/{id}`

Подсказки по реализации

**Вариант 1: Упрощение (рекомендуется, если версионирование не требуется)**
- Удалить поля `version` и `is_active` из модели `WeightTable`
- Хранить одну таблицу на профессиональную область
- При обновлении — обновлять существующую запись
- При создании — создавать новую или обновлять существующую (upsert по `prof_activity_id`)

**Вариант 2: Сохранение версионирования с автоактивацией**
- Сохранить модель с версиями
- При создании новой версии автоматически деактивировать старую и активировать новую
- При обновлении существующей — обновлять запись (если активна) или создавать новую версию с автоактивацией

**Рекомендация:**
- Если история изменений не требуется — использовать Вариант 1 (упрощение)
- Если требуется аудит/история — использовать Вариант 2 с автоактивацией

Связанные объекты
- Модель: `app/db/models.py::WeightTable` (поля `version`, `is_active`, `weights`)
- Роутер: `app/routers/weights.py` (эндпоинты `/upload`, `/{id}/activate`)
- Сервис: `app/services/weight_table.py::WeightTableService`
- Репозиторий: `app/repositories/weight_table.py::WeightTableRepository`
- Фронтенд: `frontend/src/views/AdminWeightsView.vue`, `frontend/src/api/weights.js`
- Использование: `app/services/scoring.py` (использует активные таблицы для расчёта)

Оценка
- Backend (эндпоинт обновления + упрощение модели, если требуется): 4–6 ч
- Frontend (логика редактирования + UX): 2–3 ч
- Миграции БД (если удаляется версионирование): 1–2 ч
- Тесты: 2–3 ч
- **Итого: 9–14 ч** (в зависимости от выбранного варианта)

