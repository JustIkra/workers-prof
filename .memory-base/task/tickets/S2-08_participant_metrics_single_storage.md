### Заголовок
Переработка системы метрик: персональное хранилище метрик участника, без привязки к отчётам, с обновлением по последней загрузке

### Контекст и мотивация
Сейчас значения метрик сохраняются в разрезе конкретного отчёта и далее используются в вычислениях. Это усложняет отображение «актуальных» метрик участника и приводит к дублированию при многократных загрузках отчётов. Бизнес‑правило: у участника на каждый код метрики хранится одно актуальное значение, извлечённое из любого загруженного отчёта; при повторной загрузке более позднего отчёта значение должно обновляться.

### Требование (одно предложение)
Для каждого участника хранить по одному актуальному значению на каждую метрику, независимо от отчётов; при получении новой метрики того же кода — выполнять upsert и считать актуальным значение из последнего по времени загруженного отчёта.

### Термины и определения
- «Актуальная метрика участника» — пара `(participant_id, metric_code) → {value, updated_at, source_report_id}`; хранит последнее подтверждённое значение.
- «Последний отчёт» — отчёт с максимально поздней `created_at`/`uploaded_at` датой среди всех отчётов участника, из которого была извлечена конкретная метрика.

### Объём работ (Scope)
- Backend:
  - Ввести новое хранилище актуальных метрик участника (см. раздел «Изменения модели данных»).
  - В пайплайне извлечения (Celery) вместо сохранения значения к отчёту — выполнять upsert в хранилище участника по ключу `(participant_id, metric_code)` с правилом «более поздний источник имеет приоритет».
  - Сохранить ссылку `last_source_report_id` как трассировку происхождения (опционально для UI/отладки), но бизнес‑логика не должна требовать наличия отчёта для чтения метрики.
  - Обновить сервисы и репозитории, использующие метрики, чтобы они читали только актуальные значения участника.
  - Миграция и backfill из существующих данных.
- Frontend:
  - Экран участника и формы редактирования/просмотра метрик переключить на чтение «актуальных метрик участника».
  - После загрузки нового отчёта — обновлять список метрик без навигации к конкретному отчёту.

### Вне объёма (Non‑goals)
- Хранение полной истории изменений значений метрик (аудит) — не требуется в этом тикете. Если история нужна, будет отдельный тикет.
- Изменения схемы расчёта пригодности/весов — только перепривязка к новому источнику метрик.

### Изменения модели данных
- Текущее: значения лежат в `extracted_metric` и завязаны на `report_id`.
- Предлагаемое:
  - Новая таблица `participant_metric`:
    - `id` (PK)
    - `participant_id` (FK → participant, NOT NULL)
    - `metric_code` (TEXT, NOT NULL) — ссылочная целостность по `metric_def.code`
    - `value` (DECIMAL(4,2), NOT NULL) — валидация диапазона [1..10] и формат RU
    - `confidence` (DECIMAL(4,3), NULL) — при наличии из извлечения
    - `last_source_report_id` (FK → report, NULL) — для трассировки
    - `updated_at` (TIMESTAMP WITH TIME ZONE, NOT NULL, default now())
    - Уникальный индекс `(participant_id, metric_code)` с upsert.
  - `extracted_metric` остаётся для технической совместимости/трассировки на период миграции, но бизнес‑чтение переводится на `participant_metric`.

### Алгоритм upsert при извлечении
1. Определить `participant_id` по отчёту.
2. Для каждой извлечённой пары `{metric_code, value, confidence}`:
   - Считать текущую запись из `participant_metric` по `(participant_id, metric_code)`.
   - Если записи нет — вставить.
   - Если запись есть — сравнить «приоритет» источника:
     - По умолчанию приоритет определяется по `report.uploaded_at`/`created_at` (более поздняя дата → заменить).
     - При одинаковых датах — заменить, если новое значение пришло с большей `confidence`; иначе оставить прежнее.
   - Обновить `value`, `confidence`, `last_source_report_id`, `updated_at`.

### Изменения API
- Router `metrics`:
  - Добавить/изменить endpoints для получения и обновления «актуальных метрик участника», например:
    - `GET /api/participants/{participant_id}/metrics` — список актуальных метрик.
    - `PUT /api/participants/{participant_id}/metrics/{metric_code}` — ручное обновление значения админом (опционально).
- Router `reports`:
  - Поведение загрузки отчёта не меняется с точки зрения клиента; после завершения извлечения обновляется состояние «актуальных метрик».

### Изменения сервисов
- `ScoringService` и все потребители метрик должны читать из `participant_metric`.
- Сервисы нормализации/маппинга оставляем прежними, но их выход пишем в upsert‑слой участника.

### Миграция и обратная совместимость
- Alembic:
  - Создать таблицу `participant_metric` и индексы.
  - Backfill: для каждого участника и `metric_code` выбрать самое позднее по времени значение из `extracted_metric` (или `report.created_at`) и заполнить `participant_metric`.
  - Сохранить `last_source_report_id` для выбранной записи.
- Переходный период:
  - Чтение для UI/скора — только из `participant_metric`.
  - Запись в `extracted_metric` можно временно оставить (лог/аудит) до удаления в отдельном тикете.

### Требования к качеству данных и валидации
- Диапазон значений: `^(?:10|[1-9])([,.][0-9])?$` с последующей нормализацией в Decimal.
- Обязательная валидация, что для расчёта пригодности присутствуют все требуемые метрики; отсутствие — явная ошибка с описанием.

### Тестирование
- Backend (pytest):
  - Юнит‑тесты upsert‑логики: вставка, обновление по более поздней дате, tie‑break по `confidence`.
  - Интеграционные: загрузка двух отчётов подряд с разными значениями той же метрики → в `participant_metric` остаётся значение из последнего.
  - Миграция backfill: корректное наполнение при существующих данных.
- Frontend (vitest/Playwright):
  - Отображение актуальных метрик на карточке участника.
  - После загрузки отчёта список метрик обновляется без перехода к отчёту.

### Критерии приёмки
- Для участника по каждой метрике хранится ровно одно актуальное значение.
- Повторная загрузка отчёта с той же метрикой обновляет значение, если отчёт новее (или равен по времени, но с большей confidence).
- Расчёт пригодности читает только актуальные метрики участника.
- UI участника показывает те же значения, что вернёт `GET /api/participants/{id}/metrics`.
- Миграция успешно переносит существующие данные; регрессий в расчётах нет.

### Риски и открытые вопросы
- Нужна ли полная история изменений метрик? Если да — последующий тикет на `participant_metric_history` с аудитом.
- Какое поле отчёта используем для сравнения времени: `uploaded_at` или `created_at`? По умолчанию — `uploaded_at`, при отсутствии — `created_at`.

### План реализации (шаги высокого уровня)
1. Миграция Alembic: таблица `participant_metric`, индексы, backfill.
2. Репозитории/сервисы: чтение/запись актуальных метрик, upsert‑логика.
3. Обновить Celery‑пайплайн извлечения: запись в `participant_metric` вместо привязки к отчёту.
4. Обновить `ScoringService` и потребители.
5. API endpoints для чтения актуальных метрик.
6. Frontend: переход чтения на новые endpoints, обновление после загрузки отчёта.
7. Тесты и документация.


